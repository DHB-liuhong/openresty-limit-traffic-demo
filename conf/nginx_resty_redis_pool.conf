worker_processes  1;
error_log logs/error.log debug;

events {
	worker_connections 1024;
}

http {
	lua_shared_dict limit_conn_store 100M;
#	lua_package_path 'conf/?.lua;;';
	lua_code_cache on;
	upstream apache.org {
		server apache.org;
	}

	upstream nginx.org {
		server nginx.org;
	}

	log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
	
	server {
		listen 8080;
		access_log logs/access.log main;	

# 验证openresty redis 连接池使用和非连接池性能差异
# 		没有使用连接池
    	location /testNoPool {
	        content_by_lua_block {
	            local redis = require "resty.redis"
	            local red = redis:new()

	            red:set_timeout(1000) -- 1 sec

	            local ok, err = red:connect("127.0.0.1", 6379)
	            if not ok then
	                ngx.say("failed to connect: ", err)
	                return
	            end

	            -- 获取重复使用的次数
	            local count
	            count, err = red:get_reused_times()

	            if 0 == count then
	                ngx.log(ngx.INFO, "该连接属于第一次创建 ", err)
	            elseif err then
	                ngx.say("failed to get reused times: ", err)
	                return
	            end

	            ok, err = red:set("dog", "an animal")
	            if not ok then
	                ngx.say("failed to set dog: ", err)
	                return
	            end

	            ngx.say("set result: ", ok)
	        }
    	}

# 			 使用了连接池
    	location /testPool {
	        content_by_lua_block {
	            local redis = require "resty.redis"
	            local red = redis:new()

	            red:set_timeout(1000) -- 1 sec

	            local ok, err = red:connect("127.0.0.1", 6379)
	            if not ok then
	                ngx.say("failed to connect: ", err)
	                return
	            end

	            -- 获取重复使用的次数
	            local count
	            count, err = red:get_reused_times()
	            ngx.log(ngx.INFO, "该连接已重复使用次数 ", count)
	            if 0 == count then
	                ngx.log(ngx.INFO, "该连接属于第一次创建 ", err)
	            elseif err then
	                ngx.say("failed to get reused times: ", err)
	                return
	            end

	            ok, err = red:set("dog", "an animal")
	            if not ok then
	                ngx.say("failed to set dog: ", err)
	                return
	            end

	            ngx.say("set result: ", ok)

	            -- 连接池大小是100个，并且设置最大的空闲时间是 10 秒
	            local ok, err = red:set_keepalive(10000, 100)
	            if not ok then
	                ngx.say("failed to set keepalive: ", err)
	                return
	            end
	        }
    	}
	}	
}
